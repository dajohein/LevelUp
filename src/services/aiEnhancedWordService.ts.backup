/**
 * AI-Enhanced Word Service
 * 
 * Simplified version that extends existing services with basic AI capabilities:
 * - AI-optimized quiz mode selection
 * - Real-time performance tracking and analysis
 * - Simple intervention recommendations
 */

import { WordProgress } from '../store/types';
import { Word } from './wordService';
import {
  LearningSession,
  WordGroup,
  createLearningSession,
  AIQuizModeOverride
} from './spacedRepetitionService';
import { 
  selectQuizModeWithAI,
  optimizeLearningSession
} from './adaptiveLearningEngine';
import { logger } from './logger';

// AI-Enhanced Configuration
interface AIEnhancedConfig {
  enableAI: boolean;
  adaptiveDifficulty: boolean;
  smartQuizMode: boolean;
  realTimeOptimization: boolean;
  interventionThreshold: number;
}

const DEFAULT_AI_CONFIG: AIEnhancedConfig = {
  enableAI: true,
  adaptiveDifficulty: true,
  smartQuizMode: true,
  realTimeOptimization: true,
  interventionThreshold: 0.3
};

// AI-Enhanced Word Service
export class AIEnhancedWordService {
  private config: AIEnhancedConfig;
  private sessionPerformance: any[] = [];
  private currentWord: Word | null = null;
  private sessionStats = {
    currentIndex: 0,
    totalWords: 0,
    wordsCompleted: 0,
    accuracy: 0,
    averageTime: 0,
    streak: 0,
    isComplete: false,
    aiDecisions: 0,
    sessionDuration: 0
  };
  private sessionStartTime: number = 0;
  
  constructor(config: Partial<AIEnhancedConfig> = {}) {
    this.config = { ...DEFAULT_AI_CONFIG, ...config };
    logger.info('AI-Enhanced Word Service initialized', { config: this.config });
  }
  
  /**
   * Create an AI-optimized learning session using existing infrastructure
   */
  async createAIOptimizedSession(
    targetGroup: WordGroup,
    reviewWords: Word[],
    wordProgress: Record<string, WordProgress>
  ): Promise<LearningSession> {
    
    try {
      if (!this.config.enableAI) {
        return createLearningSession(targetGroup, reviewWords, wordProgress);
      }
      
      // Create AI overrides for words based on recent performance
      const aiOverrides = new Map<string, AIQuizModeOverride>();
      
      if (this.config.smartQuizMode && this.sessionPerformance.length > 0) {
        for (const word of targetGroup.words) {
          const wordPerformance = this.sessionPerformance.filter(p => p.wordId === word.id);
          
          if (wordPerformance.length >= 2) {
            const recentErrors = wordPerformance.slice(-3).filter(p => !p.correct).length;
            
            if (recentErrors >= 2) {
              // User struggling - recommend easier mode
              aiOverrides.set(word.id, {
                quizMode: 'multiple-choice',
                reasoning: ['User struggling with this word', 'Reducing cognitive load'],
                confidence: 0.8,
                source: 'ai-intervention'
              });
            }
          }
        }
      }
      
      // Create session with AI overrides
      const session = createLearningSession(targetGroup, reviewWords, wordProgress, aiOverrides);
      
      logger.info('Created AI-optimized session', {
        groupId: targetGroup.id,
        wordsCount: session.words.length,
        reviewWordsCount: session.reviewWords.length,
        aiOverridesCount: aiOverrides.size
      });
      
      return session;
      
    } catch (error) {
      logger.error('Error creating AI-optimized session, falling back to standard', { error });
      return createLearningSession(targetGroup, reviewWords, wordProgress);
    }
  }
  
  /**
   * Get AI-optimized quiz mode for a word
   */
  async getAIQuizMode(
    word: Word,
    progress: WordProgress,
    sessionContext?: {
      recentPerformance: any[];
      currentStreak: number;
      sessionDuration: number;
    }
  ): Promise<'multiple-choice' | 'letter-scramble' | 'open-answer' | 'fill-in-the-blank'> {
    
    if (!this.config.smartQuizMode) {
      // Fall back to standard spaced repetition logic
      const { selectQuizMode } = await import('./spacedRepetitionService');
      const mastery = progress.timesCorrect / Math.max(1, progress.timesCorrect + progress.timesIncorrect) * 100;
      return selectQuizMode(mastery, 'practice', word);
    }
    
    return selectQuizModeWithAI(word, progress, 'auto', sessionContext);
  }
  
  /**
   * Real-time session optimization
   */
  async optimizeSessionRealTime(
    sessionData: {
      words: Word[];
      performance: any[];
      duration: number;
      languageCode: string;
      userId?: string;
    }
  ) {
    if (!this.config.realTimeOptimization) {
      return { recommendations: [], optimized: false };
    }
    
    try {
      const recommendations = await optimizeLearningSession(sessionData);
      
      // Check if intervention is needed
      const errorRate = sessionData.performance.filter(p => !p.correct).length / sessionData.performance.length;
      const needsIntervention = errorRate > this.config.interventionThreshold;
      
      if (needsIntervention) {
        logger.info('AI intervention triggered', {
          languageCode: sessionData.languageCode,
          errorRate,
          threshold: this.config.interventionThreshold,
          recommendationCount: recommendations.length
        });
      }
      
      return {
        recommendations,
        optimized: true,
        needsIntervention,
        analysis: {
          errorRate,
          avgResponseTime: sessionData.performance.reduce((sum, p) => sum + (p.responseTime || 1000), 0) / sessionData.performance.length,
          performanceTrend: this.calculatePerformanceTrend(sessionData.performance)
        }
      };
      
    } catch (error) {
      logger.error('Error in real-time optimization', { error, sessionData });
      return { recommendations: [], optimized: false };
    }
  }
  
  /**
   * Track performance for AI analysis
   */
  trackPerformance(performance: {
    wordId: string;
    correct: boolean;
    responseTime: number;
    mode: string;
    timestamp?: number;
    hintsUsed?: number;
  }) {
    this.sessionPerformance.push({
      ...performance,
      timestamp: performance.timestamp || Date.now()
    });
    
    // Keep only recent performance (last 50 attempts)
    if (this.sessionPerformance.length > 50) {
      this.sessionPerformance = this.sessionPerformance.slice(-50);
    }
  }
  
  /**
   * Get current session performance data
   */
  getSessionPerformance() {
    return [...this.sessionPerformance];
  }
  
  /**
   * Reset session performance tracking
   */
  resetSessionTracking() {
    this.sessionPerformance = [];
  }
  
  /**
   * Get AI-driven recommendations for current session
   */
  async getSessionRecommendations() {
    if (!this.config.enableAI || this.sessionPerformance.length < 3) {
      return [];
    }
    
    const recentPerformance = this.sessionPerformance.slice(-10);
    const errorRate = recentPerformance.filter(p => !p.correct).length / recentPerformance.length;
    const avgResponseTime = recentPerformance.reduce((sum, p) => sum + p.responseTime, 0) / recentPerformance.length;
    
    const recommendations = [];
    
    if (errorRate > 0.5) {
      recommendations.push({
        type: 'difficulty_reduction',
        message: 'Consider switching to multiple choice mode',
        confidence: 0.8
      });
    }
    
    if (avgResponseTime > 4000) {
      recommendations.push({
        type: 'break_suggestion',
        message: 'You might benefit from a short break',
        confidence: 0.7
      });
    }
    
    if (errorRate < 0.2 && avgResponseTime < 2000) {
      recommendations.push({
        type: 'challenge_increase',
        message: 'You\'re doing great! Ready for more challenge?',
        confidence: 0.9
      });
    }
    
    return recommendations;
  }
  
  /**
   * Set AI enabled/disabled
   */
  setAIEnabled(enabled: boolean): void {
    this.config.enableAI = enabled;
    logger.info(`AI learning ${enabled ? 'enabled' : 'disabled'}`);
  }

  /**
   * Initialize learning session
   */
  async initializeLearningSession(
    languageCode: string, 
    moduleId?: string, 
    wordProgress?: Record<string, WordProgress>
  ): Promise<boolean> {
    try {
      this.sessionStartTime = Date.now();
      this.sessionStats = {
        currentIndex: 0,
        totalWords: 10, // Default session length
        wordsCompleted: 0,
        accuracy: 0,
        averageTime: 0,
        streak: 0,
        isComplete: false,
        aiDecisions: 0,
        sessionDuration: 0
      };
      this.sessionPerformance = [];
      
      logger.info('Learning session initialized', { languageCode, moduleId });
      return true;
    } catch (error) {
      logger.error('Failed to initialize learning session', { error });
      return false;
    }
  }

  /**
   * Get current word with AI-enhanced context
   */
  async getCurrentWord(): Promise<{
    word: Word | null;
    quizMode: 'multiple-choice' | 'letter-scramble' | 'open-answer' | 'fill-in-the-blank';
    options?: string[];
    isReviewWord?: boolean;
    progress?: number;
    wordType?: 'group' | 'review';
    aiDecision?: any;
    shouldShowIntervention?: boolean;
    interventionMessage?: string;
  }> {
    return {
      word: this.currentWord,
      quizMode: this.currentWord ? await this.getAIQuizMode(
        this.currentWord, 
        { wordId: this.currentWord.id, xp: 0, lastPracticed: new Date().toISOString(), timesCorrect: 0, timesIncorrect: 0 }
      ) : 'multiple-choice',
      options: this.currentWord ? [this.currentWord.word, 'option2', 'option3', 'option4'] : [],
      isReviewWord: false,
      progress: 0.5,
      wordType: 'group' as const,
      aiDecision: {
        quizMode: 'multiple-choice' as const,
        difficultyAdjustment: 0,
        reasoning: ['AI-selected quiz mode'],
        confidence: 0.8
      },
      shouldShowIntervention: false,
      interventionMessage: ''
    };
  }
    }
  }
  
  /**
   * Get current word info
   */
  async getCurrentWord() {
    return {
      word: this.currentWord,
      quizMode: this.currentWord ? await this.getAIQuizMode(
        this.currentWord, 
        { wordId: this.currentWord.id, xp: 0, lastPracticed: new Date().toISOString(), timesCorrect: 0, timesIncorrect: 0 }
      ) : 'multiple-choice'
    };
  }
  
  /**
   * Get session statistics
   */
  getSessionStats() {
    const performance = this.getSessionPerformance();
    const correctCount = performance.filter(p => p.correct).length;
    const totalCount = performance.length;
    
    return {
      wordsCompleted: totalCount,
      accuracy: totalCount > 0 ? correctCount / totalCount : 0,
      averageTime: totalCount > 0 ? performance.reduce((sum, p) => sum + p.responseTime, 0) / totalCount : 0,
      streak: this.calculateCurrentStreak(performance)
    };
  }
  
  /**
   * Set AI enabled/disabled
   */
  setAIEnabled(enabled: boolean): void {
    this.config.enableAI = enabled;
    logger.info(`AI learning ${enabled ? 'enabled' : 'disabled'}`);
  }

  /**
   * Initialize learning session
   */
  async initializeLearningSession(
    languageCode: string, 
    moduleId?: string, 
    wordProgress?: Record<string, WordProgress>
  ): Promise<boolean> {
    try {
      this.sessionStartTime = Date.now();
      this.sessionStats = {
        currentIndex: 0,
        totalWords: 10, // Default session length
        wordsCompleted: 0,
        accuracy: 0,
        averageTime: 0,
        streak: 0,
        isComplete: false,
        aiDecisions: 0,
        sessionDuration: 0
      };
      this.sessionPerformance = [];
      
      logger.info('Learning session initialized', { languageCode, moduleId });
      return true;
    } catch (error) {
      logger.error('Failed to initialize learning session', { error });
      return false;
    }
  }

  /**
   * Get current word with AI-enhanced context
   */
  async getCurrentWord(): Promise<{
    word: Word | null;
    quizMode: 'multiple-choice' | 'letter-scramble' | 'open-answer' | 'fill-in-the-blank';
    options?: string[];
    isReviewWord?: boolean;
    progress?: number;
    wordType?: 'group' | 'review';
    aiDecision?: any;
    shouldShowIntervention?: boolean;
    interventionMessage?: string;
  }> {
    return {
      word: this.currentWord,
      quizMode: this.currentWord ? await this.getAIQuizMode(
        this.currentWord, 
        { wordId: this.currentWord.id, xp: 0, lastPracticed: new Date().toISOString(), timesCorrect: 0, timesIncorrect: 0 }
      ) : 'multiple-choice',
      options: this.currentWord ? [this.currentWord.translation, 'option2', 'option3', 'option4'] : [],
      isReviewWord: false,
      progress: 0.5,
      wordType: 'group' as const,
      aiDecision: {
        quizMode: 'multiple-choice' as const,
        difficultyAdjustment: 0,
        reasoning: ['AI-selected quiz mode'],
        confidence: 0.8
      },
      shouldShowIntervention: false,
      interventionMessage: ''
    };
  }

  /**
   * Get session statistics with AI metrics
   */
  getSessionStats() {
    const performance = this.getSessionPerformance();
    const correctCount = performance.filter(p => p.correct).length;
    const totalCount = performance.length;
    
    this.sessionStats.sessionDuration = this.sessionStartTime > 0 ? Date.now() - this.sessionStartTime : 0;
    
    return {
      currentIndex: this.sessionStats.currentIndex,
      totalWords: this.sessionStats.totalWords,
      wordsCompleted: totalCount,
      accuracy: totalCount > 0 ? correctCount / totalCount : 0,
      averageTime: totalCount > 0 ? performance.reduce((sum, p) => sum + p.responseTime, 0) / totalCount : 0,
      streak: this.calculateCurrentStreak(performance),
      isComplete: this.sessionStats.isComplete,
      aiDecisions: this.sessionStats.aiDecisions,
      sessionDuration: this.sessionStats.sessionDuration
    };
  }

  /**
   * Record an answer and get AI decision
   */
  async recordAnswer(isCorrect: boolean, timeSpent: number, hintsUsed: number = 0) {
    if (!this.currentWord) {
      throw new Error('No current word set');
    }
    
    // Track performance
    this.trackPerformance({
      wordId: this.currentWord.id,
      correct: isCorrect,
      responseTime: timeSpent,
      mode: 'current-mode',
      hintsUsed
    });
    
    // Update session stats
    this.sessionStats.wordsCompleted += 1;
    const stats = this.getSessionStats();
    this.sessionStats = { ...this.sessionStats, ...stats };
    
    // Get AI recommendations for next steps
    const recommendations = await this.getSessionRecommendations();
    
    return {
      correct: isCorrect,
      nextQuizMode: await this.getAIQuizMode(
        this.currentWord,
        { wordId: this.currentWord.id, xp: 0, lastPracticed: new Date().toISOString(), timesCorrect: 0, timesIncorrect: 0 }
      ),
      aiDecision: {
        quizMode: 'multiple-choice' as const,
        difficultyAdjustment: 0,
        reasoning: recommendations.map(r => r.message || ''),
        confidence: 0.8
      }
    };
  }
  
  // Private helper methods
  
  private calculateCurrentStreak(performance: any[]): number {
    let streak = 0;
    for (let i = performance.length - 1; i >= 0; i--) {
      if (performance[i].correct) {
        streak++;
      } else {
        break;
      }
    }
    return streak;
  }
  
  // ... existing methods continue ...
  
  private calculatePerformanceTrend(performance: any[]): 'improving' | 'declining' | 'stable' {
    if (performance.length < 6) return 'stable';
    
    const recent = performance.slice(-3);
    const earlier = performance.slice(-6, -3);
    
    const recentScore = recent.filter(p => p.correct).length / recent.length;
    const earlierScore = earlier.filter(p => p.correct).length / earlier.length;
    
    if (recentScore > earlierScore + 0.15) return 'improving';
    if (recentScore < earlierScore - 0.15) return 'declining';
    return 'stable';
  }
}

// Export singleton instance
export const aiEnhancedWordService = new AIEnhancedWordService();

// Export configuration management
export const configureAIWordService = (config: Partial<AIEnhancedConfig>) => {
  return new AIEnhancedWordService(config);
};

// Export types for external use
export type { AIEnhancedConfig };